# 큐

### 예시

- 음식점에 손님이 별로 없으면 손님이 오는 대로 테이블을 배정할 수 있음
- 그런데 한꺼번에 손님들이 몰려오면 줄을 세워야 함
- 데이터가 몰려드는 경우, 이를 잠시 보관할 장소로 큐가 사용됨

### 큐란?

- 가장 먼저 들어간 자료가 가장 먼저 나오는 자료구조
- 선입선출(FIFO: First-In First-Out)의 특성을 갖는 자료구조
- A, B , C를 순서대로 넣으면(삽입) 꺼낼(삭제) 때도 같은 순서인 A, B, C로 나오게 됨
- 이때 삽입이 일어나는 곳을 후단(rear)이라 하고, 삭제가 일어나는 곳을 전단(front)이라 부름
- 시간이나 속도 차이를 극복하기 위한 임시 기억 장치(버퍼(buffer))로 사용됨

### 큐의 연산

```python
enqueue(e): 새로운 요소 e를 큐의 맨 뒤에 추가
dequeue(): 큐의 맨 앞에 있는 요소를 꺼내서 반환
isEmpty(): 큐가 비어 있으면 True를, 아니면 False를 반환
isFull(): 큐가 가득 차 있으면 True를, 아니면 False를 반환
peek(): 큐가 맨 앞에 있는 요소를 삭제하지 않고 반환
size(): 큐에 들어 있는 전체 요소의 수를 반환
```

- 삽입과 삭제를 각각 enqueue와 dequeue라고 부름
- 큐에서도 두 가지 오류 상황을 만날 수 있음
    - 포화 상태인 큐에 enqueue() 연산을 실행하는 경우의 오버플로(overflow) 오류
    - 공백인 큐에서 dequeue()이나 peek() 연산을 실행하는 경우 발생한느 언더플로(underflow) 오류
    - 큐를 안정적으로 사용하기 위해서는 상태 검사가 필수적임

### 배열 구조의 큐를 위한 데이터

- 큐도 배열 구조와 연결된 구조로 구현할 수 있음 (다만 책에서는 배열 구조를 이용함)
- 고정된 용량의 큐를 클래스로 구현할 예정

```python
array[]: 큐 요소들을 저장할 배열
capacity: 큐에 저장할 수 있는 요소의 최대 개수
rear: 맨 마지막(후단) 요소의 위치(인덱스)
front: 첫 번째(전단) 요소 바로 이전의 위치(인덱스)
```

- 배열(array)과 용량(capacity)은 스택에서와 동일함
- 스택에서 상단(top)만을 사용한 것에 비해 큐는 두 개의 변수가 필요함
- 삽입과 삭제가 다른 쪽에서 이루어져야 하기 때문임
- 삽입 연산은 rear를 먼저 하나 증가시킨 후, 그 자리에 새로운 요소를 넣으면 됨
- 삭제 연산은 front를 하나 증가 시킨 후, 그 자리의 요소를 반환하면 됨
- 맨 처음에는 큐가 공백이어야 하므로 front와 rear를 모두 -1로 초기화함

<aside>

**front를 다르게 정의해도 될까?**

- 문제 없음
- 예를 들어 front를 전단 요소 자체의 인덱스로 정의할 수도 있음
- 이 경우, 삭제 연산은 front를 먼저 증가 시킨 후, (front-1)번째 요소를 반환해야 함
</aside>

### 선형 큐의 문제점과 원형 큐의 원리

- 용량이 5인 공백 상태의 큐에 5개의 요소 A ~ E를 삽입(enqueue)하고 두 번의 삭제(dequeue)를 순서대로 수행하고, 이 상태에서 F를 삽입(enqueue(F))하려면 문제가 생김
- 큐의 앞부분에 공간이 있는데도 rear를 더 증가시킬 수 없으므로 새로운 요소 F를 후단에 삽입할 수 없는 것임
- 어쩔 수 없이 큐의 요소들을 모두 최대한 앞으로 옮겨 후단에 공간을 확보한 다음 삽입해야 함
- 이렇게 동작하는 큐를 선형 큐(linear queue)라고 함
- 동작을 이해하기는 쉽지만 요소들의 이동이 필요하므로 효율적이지는 않음
- 배열을 선형이 아니라 원형으로 생각하면 선형 큐의 문제를 깔끔하게 해결할 수 있음
- 이러한 큐를 원형 큐(circular queue)라고 함
- 실제로 배열이 원형이 되는 게 아니라 인덱스 front와 rear를 원형으로 회전시키는 개념임
- 시계 방향의 회전은 front나 rear가 계속 증가하다가 용량(capacity)과 같아지면 이들을 다시 0으로 만들어주면 됨

```python
# if와 같은 조건문으로 처리할 수도 있지만 나머지 연산(%)을 이용하면 더 간결하게 처리할 수 있음
# 전단 회전 front <- (front+1) % capacity
# 후단 회전 rear <- (rear+1) % capcity
```

- 예를 들어 삽입과 관련된 rear는 0, 1, 2, 3, 4의 순으로 증가하다가 `(4+1)%5` 가 되어 다시 0으로 되돌아감
- 삭제와 관련된 front도 같은 방법으로 시계 방향으로 회전함

### 원형 큐의 클래스 구현

**클래스 선언과 멤버 변수 초기화**

```python
class ArrayQueue:
		def __init__(self, capacity = 10): # 생성자 정의
				self.capacity = capacity # 용량(고정)
				self.array = [None] * capacity # 요소들을 저장할 배열
				self.front = 0 # 전단 인덱스
				self.rear = 0 # 후단 인덱스
```

**공백 상태와 포화 상태를 검사하는 isEmpty()와 isFull() 연산**

- 원형 큐의 공백 상태는 front == rear인 경우임
- 이들이 0이 되어야 할 필요는 없음
- 단지 front와 rear가 같은 곳을 가리키기만 하면 큐는 공백 상태임
- 포화 상태를 체크할 때, front == rear를 사용하면 공백 상태와 구분되지 않음
- 따라서 원형 큐에서는 보통 하나의 자리를 비워두는 전략을 사용함
- 즉 front가 rear의 바로 다음에 있으면 포화 상태라고 정의함
- 시계 방향의 회전까지 고려하면, front == (rear+1) % capacity가 포화 상태임